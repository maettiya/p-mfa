# P-MFA — Technical Architecture
_A proximity-based multi-factor authentication system using BLE, device pairing, and cryptographic verification._

---

# 1. System Overview

P-MFA consists of **three cooperating components**:

1. **Mobile Device (Trusted Device)**
   - Acts as the "key fob."
   - Broadcasts encrypted BLE presence.
   - Stores private keys + device identity.
   - Can optionally require explicit approve/deny.

2. **Desktop Listener (Client App)**
   - Runs on laptop/desktop.
   - Listens for trusted BLE signal within proximity.
   - Performs a cryptographic handshake.
   - Exposes a local API (localhost server) for browsers/apps.

3. **P-MFA Service (Backend Broker)**
   - Stores user accounts + public keys.
   - Issues signed proximity-verification tokens.
   - Used by websites/apps to validate proximity authentication.

These three components form a closed trust triangle:

phone  ⇄  desktop  ⇄  backend  ⇄  website/app

---

# 2. Components in Detail

## 2.1 Mobile App (iOS → Android later)

Responsibilities:

- Generate and store a **device keypair** on first install:
  - Private key → Secure Enclave / Keychain
  - Public key → Upload to P-MFA backend

- Broadcast a BLE Advertisement:
  - Contains:
    - Rotating encrypted ephemeral ID
    - Public key ID (not the full key)
    - Timestamp or rolling window

- Support pairing workflow:
  - Scan QR code generated by desktop
  - Exchange public keys
  - Confirm device binding

- Optionally show a prompt for high-risk approvals:
  “Do you want to approve this login?”

---

## 2.2 Desktop Listener (Electron + Node.js)

Responsibilities:

- Scan for BLE advertisement packets
- Match rotating BLE ID against:
  - Known paired devices
  - Allowed proximity radius

- Perform handshake:
  1. Exchange ephemeral public keys
  2. Validate signatures
  3. Generate shared session key
  4. Prove liveness
  5. Verify physical proximity (RSSI + sanity checks)

- Run a local API server on `http://localhost:PORT`
  Exposes endpoints like:

GET /status
GET /proximity
POST /assert

Used by:
- Browser extensions
- Websites using JS SDK
- Desktop apps

---

## 2.3 Backend Broker (API Service)

Responsibilities:

- Manage users + device registrations
- Store public keys
- Store pairing events
- Issue signed tokens (“Proximity Verified Assertions”)

Example proximity token:

```json
{
  "user_id": "12345",
  "device_id": "ABCDE",
  "proximity": "verified",
  "verified_at": 1731888112,
  "trust_score": 0.92,
  "signature": "..."
}
```

Apps use the token to confirm if proximity was valid at login time.

Backend stack:
- Ruby on Rails API mode **or** Node.js Express
- PostgreSQL
- Redis (optional for token caching)

---

# 3. Authentication Flow (Step-by-Step)

## 3.1 Pairing Flow (One-Time Setup)

1. User installs mobile app.
2. Mobile app generates keypair.
3. Desktop app generates keypair.
4. Desktop shows QR code.
5. Phone scans → exchange public keys.
6. Backend binds both devices to the same user.
7. BLE keys + rotating IDs established.

Result:
Phone + desktop are cryptographically paired.

---

## 3.2 Login Flow (Normal Use)

When user goes to a login page:

1. Website → asks desktop client via localhost:
   `GET /proximity`
2. Desktop scans BLE:
   - Trusted phone found?
   - Proximity < threshold?
   - Timestamp fresh?
3. Desktop and phone perform cryptographic handshake:
   - Exchange ephemeral keys
   - Validate signatures
   - Derive shared secret
4. Desktop produces “Proximity Verified Assertion” (PVA)
5. Website backend verifies PVA via P-MFA backend
6. If valid → automatic login
   Else → fallback to password/2FA

---

# 4. Security Model

## 4.1 Key Principles

- Private keys never leave devices.
- BLE IDs rotate frequently.
- Every login has a fresh handshake.
- Proximity validated via RSSI + anti-relay logic.

## 4.2 Cryptography

- X25519 (key exchange)
- Ed25519 (signatures)
- AES-GCM (message encryption)
- Backend signs tokens with Ed25519

## 4.3 Anti-Relay Measures

- RSSI smoothing window
- Time-bound challenge
- Rotating BLE IDs every 100–300ms
- Tight timestamp validation

---

# 5. Data Structures

## 5.1 BLE Advertisement Payload

```
{
  ephemeral_id: "abc123",
  device_id_hash: "df09cc",
  timestamp: 1731888000,
  signature: "ed25519..."
}
```

## 5.2 Pairing Record (Backend)

```
user_id
phone_public_key
desktop_public_key
paired_at
```

## 5.3 Proximity Assertion Payload

```
proximity: verified | failed
confidence: float
nonce: string
expires_at: timestamp
signature: string
```

---

# 6. Technology Choices (MVP)

### Mobile:
- iOS Swift + CoreBluetooth
- Android Kotlin later

### Desktop:
- Electron + Node
- Native Rust/Swift later

### Backend:
- Rails API mode
- PostgreSQL

### SDKs:
- JS (Web)
- Node
- Rails gem

---

# 7. Future Architecture (Post-MVP)

- Browser extension
- WebAuthn integration
- Multi-device trust graph
- Continuous presence → auto-lock/auto-unlock
- Enterprise features
- Standardize `.well-known/p-mfa.json`

---

# 8. System Diagram (text version)

```
   Mobile Device
       |
       |  BLE (encrypted)
       |
   Desktop Listener
       |
       | HTTPS
       |
   P-MFA Backend
       |
       | Webhooks/API
       |
   Website/App
```

---

# 9. MVP Limitations

- BLE range varies
- Desktop app must run
- iOS background BLE restrictions
- Proximity is estimated, not exact
- Handshake adds ~100–300ms latency

---

# 10. Next Steps

- Build iOS BLE advertiser prototype
- Build desktop BLE scanner
- Implement pairing
- Build demo login flow
- Connect everything end-to-end
